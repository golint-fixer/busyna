package libbusyna

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
)

// Create a Makefile file with db data read form the provided channel.
func DeployMake(c <-chan CmdData, outputfile string) {
	fd, err := ioutil.TempFile(filepath.Dir(outputfile), "Makefile-")
	if err != nil {
		log.Fatal(err)
	}
	defer os.Remove(fd.Name())

	// Header:
	fd.WriteString(fmt.Sprintf("# Automatically generated by busyna\n\n"))
	fd.WriteString(".PHONY: all clean\n\n")
	fd.WriteString("all:\n\n")

	// Rules:
	targets := map[string][]CmdData{}
	for cmddata := range c {
		for target0 := range cmddata.Targets {
			target := filepath.Join(cmddata.Cmd.Dir, target0)
			if tcmds, ok := targets[target]; ok {
				targets[target] = append(tcmds, cmddata)
			} else {
				targets[target] = []CmdData{cmddata}
			}
		}
	}
	for target, cmddatas := range targets {
		fd.WriteString(fmt.Sprintf("%s:", target))
		for _, cmddata := range cmddatas {
			for dep0 := range cmddata.Deps {
				dep := filepath.Join(cmddata.Cmd.Dir, dep0)
				if dep != target {
					fd.WriteString(fmt.Sprintf(" %s", dep))
				}
			}
		}
		for _, cmddata := range cmddatas {
			fd.WriteString("\n\t")
			if cmddata.Cmd.Dir != "." && cmddata.Cmd.Dir != "" {
				fd.WriteString(fmt.Sprintf("mkdir -p \"%s\"; mkdir -p \"%s\"; cd \"%s\"; ", cmddata.Cmd.Dir, filepath.Dir(target), cmddata.Cmd.Dir))
			}
			fd.WriteString(cmddata.Cmd.Line)
		}
		fd.WriteString("\n\n")
	}

	// Fix "all" target, to depend on all targets:
	fd.WriteString("all:")
	for target := range targets {
		fd.WriteString(fmt.Sprintf(" %s", target))
	}
	fd.WriteString("\n\n")

	// Create the "clean" target:
	fd.WriteString("clean:\n\trm -f")
	for target := range targets {
		fd.WriteString(fmt.Sprintf(" '%s'", target))
	}
	fd.WriteString("\n\tfind . -depth -type d -exec rmdir {} \\; 2>/dev/null || true")
	fd.WriteString("\n\n")

	fd.Close()

	if err = os.Rename(fd.Name(), outputfile); err != nil {
		log.Fatal(err)
	}
}
