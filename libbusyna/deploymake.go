package libbusyna

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
)

// Create a dot graphviz file with db data read form the provided channel.
func DeployMake(c <-chan CmdData, outputfile string) {
	fd, err := ioutil.TempFile(filepath.Dir(outputfile), "Makefile-")
	if err != nil {
		log.Fatal(err)
	}
	defer os.Remove(fd.Name())

	// Header:
	fd.WriteString(fmt.Sprintf("# Automatically generated by busyna\n\n"))
	fd.WriteString(".PHONY: all clean\n\n")
	fd.WriteString("all:\n\n")

	// Rules:
	targets := map[string][]CmdData{}
	for cmddata := range c {
		for target := range cmddata.Targets {
			if tcmds, ok := targets[target]; ok {
				targets[target] = append(tcmds, cmddata)
			} else {
				targets[target] = []CmdData{cmddata}
			}
		}
	}
	for target, cmddatas := range targets {
		fd.WriteString(fmt.Sprintf("%s:", target))
		for _, cmddata := range cmddatas {
			for dep := range cmddata.Deps {
				if dep != target {
					fd.WriteString(fmt.Sprintf(" %s", dep))
				}
			}
		}
		for _, cmddata := range cmddatas {
			fd.WriteString(fmt.Sprintf("\n\t%s", cmddata.Cmd.Line))
		}
		fd.WriteString("\n\n")
	}

	// Fix "all" target, to depend on all targets:
	fd.WriteString("all:")
	for target := range targets {
		fd.WriteString(fmt.Sprintf(" %s", target))
	}
	fd.WriteString("\n\n")

	// Create the "clean" target:
	fd.WriteString("clean:\n\trm -f")
	for target := range targets {
		fd.WriteString(fmt.Sprintf(" '%s'", target))
	}
	fd.WriteString("\n\n")

	fd.Close()

	if err = os.Rename(fd.Name(), outputfile); err != nil {
		log.Fatal(err)
	}
}
