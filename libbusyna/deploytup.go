package libbusyna

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
)

// Create a Makefile file with db data read form the provided channel.
func DeployTup(c <-chan CmdData, outputfile string) {
	fd, err := ioutil.TempFile(filepath.Dir(outputfile), "Tupfile.lua-")
	if err != nil {
		log.Fatal(err)
	}
	defer os.Remove(fd.Name())

	// Header:
	fd.WriteString(fmt.Sprintf("-- Automatically generated by busyna\n\n"))

	/* Create our entries by joining targets */
	entries := map[int][]CmdData{}
	targets := map[string]int{}
	nentries := 0
	for cmddata := range c {
		found := false
		efound := 0
		for target0 := range cmddata.Targets {
			target := filepath.Join(cmddata.Cmd.Dir, target0)
			if e, ok := targets[target]; ok {
				found = true
				efound = e
			}
		}
		if found {
			entries[efound] = append(entries[efound], cmddata)
		} else {
			entries[nentries] = []CmdData{cmddata}
			for target0 := range cmddata.Targets {
				target := filepath.Join(cmddata.Cmd.Dir, target0)
				targets[target] = nentries
			}
			nentries++
		}
	}

	/* Dump the calculated entries */
	for ientry := 0; ientry < len(entries); ientry++ {
		cmddatas := entries[ientry]
		foundtarget := false
		targets := map[string]bool{}
		for _, cmddata := range cmddatas {
			for target0 := range cmddata.Targets {
				if !foundtarget {
					fd.WriteString("tup.frule {\n")
					fd.WriteString("\toutputs = {\n")
					foundtarget = true
				}
				target := filepath.Join(cmddata.Cmd.Dir, target0)
				if targets[target] {
					continue
				}
				fd.WriteString(fmt.Sprintf("\t\t[[%s]],\n", target))
				targets[target] = true
			}
		}
		if !foundtarget {
			/* no target, no deploy */
			continue
		}
		fd.WriteString("\t},\n")
		numdeps := 0
		deps := map[string]bool{}
		for _, cmddata := range cmddatas {
			for dep0 := range cmddata.Deps {
				if numdeps == 0 {
					fd.WriteString("\tinputs = {\n")
				}
				numdeps++
				dep := filepath.Join(cmddata.Cmd.Dir, dep0)
				if deps[dep] || targets[dep] {
					continue
				}
				fd.WriteString(fmt.Sprintf("\t\t[[%s]],\n", dep))
				deps[dep] = true
			}
		}
		if numdeps > 0 {
			fd.WriteString("\t},\n")
		}
		fd.WriteString("\tcommand = [[ ")
		createddirs := map[string]bool{".": true}
		for _, cmddata := range cmddatas {
			fd.WriteString("( ")
			if cmddata.Cmd.Dir != "." && cmddata.Cmd.Dir != "" {
				if !createddirs[cmddata.Cmd.Dir] {
					fd.WriteString(fmt.Sprintf("mkdir -p \"%s\"; ", cmddata.Cmd.Dir))
					createddirs[cmddata.Cmd.Dir] = true
				}
				fd.WriteString(fmt.Sprintf("cd \"%s\"; ", cmddata.Cmd.Dir))
			}
			fd.WriteString(fmt.Sprintf("%s ); ", cmddata.Cmd.Line))
		}
		fd.WriteString(" ]]\n")
		fd.WriteString("}\n\n")
	}

	fd.Close()

	if err = os.Rename(fd.Name(), outputfile); err != nil {
		log.Fatal(err)
	}
}
